<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>啥叫个 Context</title>
    <link href="/2021/06/10/ReactContext/"/>
    <url>/2021/06/10/ReactContext/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Context"><a href="#什么是-Context" class="headerlink" title="什么是 Context"></a>什么是 Context</h2><p>一个能将 Props 从顶层传递到最底层的方法</p><h2 id="什么时候使用-Context"><a href="#什么时候使用-Context" class="headerlink" title="什么时候使用 Context"></a>什么时候使用 Context</h2><p>有的时候很深层次的后代组件想要使用祖先组件的 state 或者方法，但是中间的组件不需要使用，如果使用 props，中间很多组件需要帮助传递参数，巨麻烦</p><p>使用 Context 不需要中间组件帮忙传递，这种方案要优于 props，且中间组件也可以使用 Context 的 Consumer 接收</p><h2 id="配合小例子搞明白儿的"><a href="#配合小例子搞明白儿的" class="headerlink" title="配合小例子搞明白儿的"></a>配合小例子搞明白儿的</h2><h4 id="实现功能：将-state-和-add-方法传递给子组件及其它的后代组件"><a href="#实现功能：将-state-和-add-方法传递给子组件及其它的后代组件" class="headerlink" title="实现功能：将 state 和 add() 方法传递给子组件及其它的后代组件"></a>实现功能：将 state 和 add() 方法传递给子组件及其它的后代组件</h4><ul><li><p>先创建好 Context.js(祖先)、ContextItem1.js(父级)、ContextItem2.js(子级)三个 js 组件，并引入对应组件内</p></li><li><p>在祖先级组件中创建一个 Context 并导出  Provider(提供) 和 Consumer(消费)</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; Component, createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; Provider, Consumer &#125; = createContext(<span class="hljs-string">&quot;blue&quot;</span>);<br><span class="hljs-comment">// &quot;blue&quot; 是默认值</span><br></code></pre></td></tr></table></figure><ul><li>使用 Provider 组件传递参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 定义的 state</span><br> state = &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">post</span>: <span class="hljs-number">200</span>,<br>  &#125;;<br><span class="hljs-comment">// 传递参数</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.add&#125;</span>&gt;</span>修改count<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">count</span>, <span class="hljs-attr">post</span>, <span class="hljs-attr">add:</span> <span class="hljs-attr">this.add</span> &#125;&#125;&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ContextItem1</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="hljs-comment">// 定义的方法</span><br>  add = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">post</span>: <span class="hljs-number">300</span>,<br>    &#125;);<br>  &#125;;<br></code></pre></td></tr></table></figure><ul><li>接收参数<ul><li>子组件想要使用祖先组件共享的 Context，先导入 Consumer，使用 Consumer 可以获取共享的 Context</li><li>Consumer 的使用方式：给 Consumer 组件传递一个函数，这个函数的参数就是共享 Context 的值，而且这个函数需要返回对应组件的节点内容</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 父级组件内</span><br><span class="hljs-comment">// 导入 Consumer</span><br><span class="hljs-keyword">import</span> &#123; Consumer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Context&quot;</span>;<br><span class="hljs-comment">// 接收参数</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span>&gt;</span></span><br><span class="xml">  &#123;(value) =&gt; (</span><br><span class="xml">    // value 是形参，可以改为其他名字</span><br><span class="xml">    // value 接收的是一个对象，需要使用 value.[属性名]</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;value.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;value.add&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ContextItem2</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    )&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Consumer</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子级组件接收参数是一样的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; Consumer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Context&quot;</span>;<br><span class="hljs-keyword">const</span> ContextItem2 = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span>&gt;</span></span><br><span class="xml">      &#123;(value) =&gt; (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>&#123;value.post&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      )&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Consumer</span>&gt;</span></span><br>  );<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ContextItem2;<br></code></pre></td></tr></table></figure><h2 id="使用多个-Context"><a href="#使用多个-Context" class="headerlink" title="使用多个 Context"></a>使用多个 Context</h2><ul><li>依然使用刚才创建的组件，创建 Context 导出  Provider、Consume 时起个名字</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">Provider</span>: ThemeProvider, <span class="hljs-attr">Consumer</span>: ThemeConsumer &#125; = createContext();<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">Provider</span>: DemoProvider, <span class="hljs-attr">Consumer</span>: DemoConsumer &#125; = createContext();<br></code></pre></td></tr></table></figure><ul><li>使用起好名字的 Provider 组件传递参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-built_in">this</span>.add&#125;&gt;修改count&lt;/button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">count</span>, <span class="hljs-attr">post</span>, <span class="hljs-attr">add:</span> <span class="hljs-attr">this.add</span> &#125;&#125;&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">DemoProvider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ContextItem1</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">DemoProvider</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>使用起好名字的 Consumer 组件接收参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 子组件内</span><br><span class="hljs-comment">// 导入要使用的 Consumer</span><br><span class="hljs-keyword">import</span> &#123; ThemeConsumer, DemoConsumer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Context&quot;</span>;<br><span class="hljs-comment">// 接收参数</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeConsumer</span>&gt;</span></span><br><span class="xml">  &#123;(themeContext) =&gt; (</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">DemoConsumer</span>&gt;</span></span><br><span class="xml">      &#123;(demoContext) =&gt; (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>&#123;themeContext.post&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>&#123;demoContext&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      )&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">DemoConsumer</span>&gt;</span></span><br><span class="xml">    )&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ThemeConsumer</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>啊，我已经懂了，但是没有完全懂</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零搞清楚什么是构造函数</title>
    <link href="/2021/06/01/Constructor/"/>
    <url>/2021/06/01/Constructor/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是构造函数"><a href="#什么是构造函数" class="headerlink" title="什么是构造函数"></a>什么是构造函数</h1><p>概念：通过 new 关键字来调用的函数，称为构造函数</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>构造函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是防抖节流</title>
    <link href="/2021/05/23/Debounce&amp;Throttle/"/>
    <url>/2021/05/23/Debounce&amp;Throttle/</url>
    
    <content type="html"><![CDATA[<p>什么是快乐星球，什么是防抖节流</p><h2 id="从一个滚动条监听开始说起"><a href="#从一个滚动条监听开始说起" class="headerlink" title="从一个滚动条监听开始说起"></a>从一个滚动条监听开始说起</h2><p>很多网站都有一个 “返回顶部” 按钮，当你向下滚动到一定位置时，这个按钮才会出现。这时候就抽象出这个功能需求——<strong>监听浏览器滚动事件，返回当前滚条与顶部的距离</strong></p><p>这个很简单，直接就是一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showLocation</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;滚动条位置：&quot;</span> + scrollTop);<br>&#125;<br><span class="hljs-built_in">window</span>.onscroll = showLocation;<br></code></pre></td></tr></table></figure><p>这时候你就会发现，好家伙！只需轻轻一滚，就能执行<strong>6-7 次</strong>！</p><img src="/.io//log.png" width="300" height="300"><p>然而实际上我们并不需要如此高频的反馈，毕竟浏览器的性能是有限的，不应该浪费在这里，所以接着讨论如何优化这种场景</p><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p><strong>触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</strong></p><p>直接看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 借助闭包</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      <span class="hljs-comment">// 进入该分支语句说明当前正在一个计时过程中，并且又触发了相同事件。</span><br>      <span class="hljs-comment">// 所以要取消当前的计时，重新开始计时</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(fn, delay);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(fn, delay);<br>      <span class="hljs-comment">// 进入该分支说明当前并没有在计时，那么就开始一个计时</span><br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showLocation</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;滚动条位置：&quot;</span> + scrollTop);<br>&#125;<br><span class="hljs-built_in">window</span>.onscroll = debounce(showLocation, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>此时会发现，必须在停止滚动 1 秒以后，才会打印出滚动条位置</p><p>到这里，已经把<strong>防抖</strong>实现了，现在给出定义：</p><ul><li>对于<strong>短时间内连续触发</strong>的事件，防抖就是让<strong>某个时间期限内，事件处理函数只执行一次</strong></li></ul><h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h2><p>对于防抖，如果用户一直拖动进度条，就一直不会触发函数</p><p><strong>如果想让用户在不断拖动滚动条情况下，也能在某个时间间隔之后给出反馈呢？</strong></p><p>那么这是我们就可以设计一个<strong>类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活</strong>（类似于技能冷却时间）</p><p>这里借助 setTimeout 来做一个简单的实现，加上一个状态位 valid 来表示当前函数是否处于工作状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> valid = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!valid) &#123;<br>      <span class="hljs-comment">// 进入该分支跳出函数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 执行函数并且在间隔期内把状态位设为无效</span><br>    valid = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn();<br>      valid = <span class="hljs-literal">true</span>;<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就会发现，如果一直拖着滚动条进行滚动，那么会以 1s 的时间间隔，持续输出当前位置和顶部的距离</p><p>那么同样，<strong>节流</strong>的定义大概为：</p><ul><li><strong>短时间内大量触发</strong>同一事件，那么在函数执行一次之后，<strong>该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让我头疼的闭包</title>
    <link href="/2021/05/16/Closure/"/>
    <url>/2021/05/16/Closure/</url>
    
    <content type="html"><![CDATA[<p>在搞清楚闭包之前，必须理解 JavaScrip 的变量作用域</p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量的作用域包括两种：<strong>全局变量</strong> 和 <strong>局部变量</strong></p><p>在 JavaScrip 中，函数内部可以直接读取全局变量，而在函数外部无法读取函数内的局部变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 3</span><br>&#125;<br>f1();<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><h2 id="如何从外部读取局部变量"><a href="#如何从外部读取局部变量" class="headerlink" title="如何从外部读取局部变量"></a>如何从外部读取局部变量</h2><p>在函数的内部，再定义一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 3</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，函数 f2 被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。</p><p>这里就提到了 JavaScript 语言特有的 “链式作用域” 结构：子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>这时只要把 f2 作为返回值，就可以在 f1 外部读取它的内部变量了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2;<br>&#125;<br><span class="hljs-keyword">var</span> post = f1();<br><br>post(); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>上述的 f2 函数就是闭包，<strong>闭包就是能够读取其他函数内部变量的函数</strong></p><h2 id="闭包有什么用"><a href="#闭包有什么用" class="headerlink" title="闭包有什么用"></a>闭包有什么用</h2><p>闭包最大的用处有两个：</p><ul><li><p>可以读取函数内部的变量</p></li><li><p>让这些变量的值始终保持在内存中</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC 和 MVVM 是个啥</title>
    <link href="/2021/03/22/MVCandMVVM/"/>
    <url>/2021/03/22/MVCandMVVM/</url>
    
    <content type="html"><![CDATA[<p>MVC 和 MVVM 是一种程序开发设计模式</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="什么是-MVC"><a href="#什么是-MVC" class="headerlink" title="什么是 MVC"></a>什么是 MVC</h2><p>MVC 是 Model View Controller 的缩写</p><ul><li><p>Model：模型层，可以在数据库中存取数据，用于处理数据逻辑</p></li><li><p>View：视图层，渲染用户界面逻辑</p></li><li><p>Controller：控制器，接收来自视图界面的请求，并交给模型进行处理，起到了一个连接的作用</p></li></ul><h2 id="它们仨什么关系"><a href="#它们仨什么关系" class="headerlink" title="它们仨什么关系"></a>它们仨什么关系</h2><p>看图说话</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90dFZXdXJMb0dWaWFkeUV6WllDRWlhbXIxSWhKaWNlMUpGUXlCaEQ1Q2RQSHA0RllnRXVVVGVaRDk0RzdKYUNHS3BYNGhpYTdibm1rcU9Fbk5FcEppYUhCaWJSUS82NDA?x-oss-process=image/format,png#pic_center" alt="三者关系图"></p><p>大致过程：</p><p>用户在视图交互，然后请求发送到控制器，控制器根据请求类型和请求的指令发送到相应的模型，模型可以与数据库进行交互，一通操作之后（指增删改查），根据业务的逻辑选择相应的视图进行显示，用户获得此次交互的反馈信息</p><h2 id="MVC-的特点"><a href="#MVC-的特点" class="headerlink" title="MVC 的特点"></a>MVC 的特点</h2><p>模型和视图之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。</p><h2 id="MVC-的优点"><a href="#MVC-的优点" class="headerlink" title="MVC 的优点"></a>MVC 的优点</h2><ul><li>耦合性低</li></ul><p>视图层和业务层分离，允许更改视图层代码而不用重新编译模型和控制器代码（改写html, css, javascirpt 的代码，并不需要重启服务器）</p><ul><li>重用性高</li></ul><p>分层后更有利于组件的重用：控制层可独立成一个能用的组件，视图层也可做成通用的操作界面</p><ul><li>可维护性高</li></ul><p>分离视图层和业务逻辑层使得 Web 应用更易于维护和修改</p><h2 id="MVC-的缺点"><a href="#MVC-的缺点" class="headerlink" title="MVC 的缺点"></a>MVC 的缺点</h2><ul><li>视图与控制器连接过于紧密</li></ul><p>虽然视图与控制器是相互分离，但是它们又联系紧密，视图没有控制器的存在，其应用是很有限的，反之亦然，所以会影响它们的独立重用</p><ul><li>不适合小型，中等规模的应用程序</li></ul><p>花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失（例如仅仅需要到数据库查信息，如果不分层设计我们可以直接从视图型层到模型去访问，效率上会有所提高，如果以代码的复杂性为代价，多了一层，代码量大大增加，在这个时候就降低了开发效率）</p><ul><li>视图对模型数据的低效率访问</li></ul><p>依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p><ul><li>一般高级的界面工具或构造器不支持模式</li></ul><p>改造这些工具以适应MVC需要和建立分离的部件的代价很高，造成 MVC 使用的困难。</p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><p>MVVM 是 Model View ViewModel 的缩写</p><ul><li><p>Modal：模型层，指的是后端传递的数据</p></li><li><p>View：视图层，指的是所看到的页面</p></li><li><p>ViewModal：视图模型层，MVVM 模式的核心，它是连接view和model的桥梁，主要用来处理业务逻辑</p></li></ul><h2 id="它们三个有什么关系"><a href="#它们三个有什么关系" class="headerlink" title="它们三个有什么关系"></a>它们三个有什么关系</h2><p>直接看图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90dFZXdXJMb0dWaWFkeUV6WllDRWlhbXIxSWhKaWNlMUpGUW9CN2M3QjlDZ0NQSDIzYVV4QjBnNzI5WkNVMERWbnBJZEh3Mzl0aWJWNlJJdWpwdEFET1VIaWJnLzY0MA?x-oss-process=image/format,png#pic_center" alt="三者关系图"></p><p>大致过程：</p><ul><li><p>将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。</p></li><li><p>将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</p></li><li><p>两个方向都实现的，就是数据的双向绑定。</p></li></ul><h2 id="MVVM-的特点"><a href="#MVVM-的特点" class="headerlink" title="MVVM 的特点"></a>MVVM 的特点</h2><p>在MVVM的框架下，视图和模型是不能直接通信的，它们通过 ViewModal 来通信，ViewModel 通常要实现一个observer 观察者。当数据发生变化，ViewModel 能够监听到数据的这种变化，然后通知到对应的视图做自动更新；而当用户操作视图，ViewModel 也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。</p><h2 id="MVVM-的优点"><a href="#MVVM-的优点" class="headerlink" title="MVVM 的优点"></a>MVVM 的优点</h2><ul><li>低耦合</li></ul><p>视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</p><ul><li>可重用性</li></ul><p>可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</p><ul><li>可测试性</li></ul><p>界面向来是比较难于测试的，而现在测试可以针对 ViewModel 来写</p><ul><li>双向数据绑定</li></ul><p>它实现了 View 和 Model 的自动同步，当 Model 的属性改变时，不需要手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变</p><h2 id="MVVM-的缺点"><a href="#MVVM-的缺点" class="headerlink" title="MVVM 的缺点"></a>MVVM 的缺点</h2><ul><li>数据绑定难以调试</li></ul><p>你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易</p><ul><li>占用内存</li></ul><p>一个大的模块中 model 也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存 </p><ul><li>数据双向绑定不利于代码重用</li></ul><p>客户端开发最常用的重用是 View，但是数据双向绑定技术，让你在一个 View 都绑定了一个 model，不同模块的 model 都不同。那就不能简单重用 View 了</p><h1 id="MVC-和-MVVM-的区别"><a href="#MVC-和-MVVM-的区别" class="headerlink" title="MVC 和 MVVM 的区别"></a>MVC 和 MVVM 的区别</h1><ul><li><p>MVVM 实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变。</p></li><li><p>MVC 是系统架构级别的（描述了构成系统的抽象组件，以及各个组件之间的是如何进行通讯），而 MVVM 只用于单页面上的。因此 MVVM 的灵活性要远大于 MVC</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
