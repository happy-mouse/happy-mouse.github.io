<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跨域资源共享(CORS)</title>
    <link href="/2021/07/12/CORS/"/>
    <url>/2021/07/12/CORS/</url>
    
    <content type="html"><![CDATA[<h1 id="跨域资源共享-CORS"><a href="#跨域资源共享-CORS" class="headerlink" title="跨域资源共享 CORS"></a>跨域资源共享 CORS</h1><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）</p><p>它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10</p><p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉</p><p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信</p><h2 id="请求分类"><a href="#请求分类" class="headerlink" title="请求分类"></a>请求分类</h2><p>浏览器将 CORS 请求分成两类：<strong>简单请求</strong>和<strong>非简单请求</strong></p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><h4 id="满足条件"><a href="#满足条件" class="headerlink" title="满足条件"></a>满足条件</h4><p>请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>HTTP 的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 <strong>Origin</strong> 字段</p><ul><li>例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /cors HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Origin</span>: http:<span class="hljs-comment">//api.bob.com</span><br>Host: api.alice.com<br>Accept-Language: en-US<br><span class="hljs-attr">Connection</span>: keep-alive<br>User-Agent: Mozilla/<span class="hljs-number">5.0</span>...<br></code></pre></td></tr></table></figure><p>上面的头信息中，Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求</p><p>如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获</p><p>如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Access-Control-Allow-Origin: http:<span class="hljs-comment">//api.bob.com</span><br>Access-Control-Allow-Credentials: <span class="hljs-literal">true</span><br>Access-Control-Expose-Headers: FooBar<br>Content-Type: text/html; charset=utf-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><ul><li><strong>Access-Control-Allow-Origin</strong></li></ul><p>该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个*，表示接受任意域名的请求。</p><ul><li><strong>Access-Control-Allow-Credentials</strong></li></ul><p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。</p><ul><li><strong>Access-Control-Expose-Headers</strong></li></ul><p>该字段可选。CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回 FooBar 字段的值。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。</p><p>非简单请求的 <strong>CORS</strong> 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 “预检” 请求。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</p><ul><li>例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;http://api.alice.com/cors&quot;</span>;<br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&quot;PUT&quot;</span>, url, <span class="hljs-literal">true</span>);<br>xhr.setRequestHeader(<span class="hljs-string">&quot;X-Custom-Header&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>xhr.send();<br></code></pre></td></tr></table></figure><p>上面代码中，HTTP 请求的方法是 PUT，并且发送一个自定义头信息 X-Custom-Header。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的 HTTP 头信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">OPTIONS /cors HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Origin</span>: http:<span class="hljs-comment">//api.bob.com</span><br>Access-Control-Request-Method: PUT<br>Access-Control-Request-Headers: X-Custom-Header<br><span class="hljs-attr">Host</span>: api.alice.com<br>Accept-Language: en-US<br><span class="hljs-attr">Connection</span>: keep-alive<br>User-Agent: Mozilla/<span class="hljs-number">5.0</span>...<br></code></pre></td></tr></table></figure><p>“预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是 Origin，表示请求来自哪个源。</p><p>除了 Origin 字段，”预检”请求的头信息包括两个特殊字段。</p><ul><li><strong>Access-Control-Request-Method</strong></li></ul><p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT。</p><ul><li><strong>Access-Control-Request-Headers</strong></li></ul><p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header。</p><h2 id="与-JSONP-的比较"><a href="#与-JSONP-的比较" class="headerlink" title="与 JSONP 的比较"></a>与 JSONP 的比较</h2><p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。</p><p>JSONP 只支持 <strong>GET</strong> 请求，CORS <strong>支持所有类型的 HTTP 请求</strong>。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算属性(Computed)和侦听器(Watch)</title>
    <link href="/2021/07/12/Computed-Watch/"/>
    <url>/2021/07/12/Computed-Watch/</url>
    
    <content type="html"><![CDATA[<h1 id="计算属性-Computed-和侦听器-Watch"><a href="#计算属性-Computed-和侦听器-Watch" class="headerlink" title="计算属性(Computed)和侦听器(Watch)"></a>计算属性(Computed)和侦听器(Watch)</h1><h2 id="计算属性-不能包含异步"><a href="#计算属性-不能包含异步" class="headerlink" title="计算属性 (不能包含异步)"></a>计算属性 (不能包含异步)</h2><p>模板内出现<strong>较多逻辑的表达式</strong>时，让模板<strong>过重且难以维护</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;example&quot;</span>&gt;&#123;&#123; message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>) &#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这个时候就应该用计算属性</p><p>• 例子：输入的一个单词首字母大写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model.lazy=<span class="hljs-string">&quot;myInput&quot;</span> /&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; upperCase &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br> computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">upperCase</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.myInput.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + <span class="hljs-built_in">this</span>.myInput.slice(<span class="hljs-number">1</span>);<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure><p>可以调用方法来达到相同效果，但是计算属性是基于它们的响应式依赖进行缓存的，多次访问 upperCase 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p><h3 id="计算属性的-setting"><a href="#计算属性的-setting" class="headerlink" title="计算属性的 setting"></a>计算属性的 setting</h3><p>• 具有侦听功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;div&gt;名字 Demo&lt;/div&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy.trim</span>=<span class="hljs-string">&quot;fullName&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>姓<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy.trim</span>=<span class="hljs-string">&quot;firstName&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy.trim</span>=<span class="hljs-string">&quot;lastName&quot;</span> /&gt;</span></span><br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    &#125;;<br>  &#125;,<br>    <span class="hljs-attr">computed</span>: &#123;<br>      <span class="hljs-attr">fullName</span>: &#123;<br>        <span class="hljs-comment">// getter</span><br>        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName;<br>        &#125;,<br>          <span class="hljs-comment">// setter</span><br>          <span class="hljs-comment">// 当计算属性被修改的时候触发，接收新的计算属性的值为参数</span><br>          <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> names = newValue.split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>];<br>            <span class="hljs-built_in">this</span>.lastName = names[names.length - <span class="hljs-number">1</span>];<br>          &#125;,<br>      &#125;,<br>    &#125;,<br></code></pre></td></tr></table></figure><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>当需要在数据变化时执行异步时使用<br>• 例子 ：监听在 input 输入问题后，延迟回答</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model.lazy=<span class="hljs-string">&quot;question&quot;</span> /&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">question</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">answer</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;;<br>&#125;,<br><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">question</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">&quot;Waiting for you to stop typing...&quot;</span>;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">&quot;难受&quot;</span>;<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure><h2 id="计算属性和-watch-的区别"><a href="#计算属性和-watch-的区别" class="headerlink" title="计算属性和 watch 的区别"></a>计算属性和 watch 的区别</h2><ul><li><p><strong>computed</strong> 适合处理的场景是，一个数据属性在它所依赖的属性发生变化时，也要发生变化，这种情况下，我们最好使用计算属性，computed 是带缓存的，只有其引用的响应式属性（属性绑定）发生改变时才会重新计算(如果引用的属性没有改变，则调用上一次缓存值)</p></li><li><p><strong>watch</strong> 适合处理的场景是，侦听一个数的变化，当该数据变化，来处理其他与之相关数据的变化（该数据影响别的多个数据）,当数据发生变化时，执行异步操作或较大开销操作的情况。</p></li></ul><p>简单来说 computed 是计算值，只有值发生变化才会执行方法; watch 是监听观察动作，有改变就执行，computed 具有缓存性，数据变化时先读取缓存，值没变这不做操作，而 watch 没有缓存，直接执行。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解 vue 生命周期钩子</title>
    <link href="/2021/07/12/lifeCycle/"/>
    <url>/2021/07/12/lifeCycle/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-组件的生命周期钩子"><a href="#vue-组件的生命周期钩子" class="headerlink" title="vue 组件的生命周期钩子"></a>vue 组件的生命周期钩子</h1><p>生命周期：组件渲染—&gt;组件销毁</p><h2 id="初始渲染阶段"><a href="#初始渲染阶段" class="headerlink" title="初始渲染阶段"></a>初始渲染阶段</h2><ul><li><p><strong>beforeCreate：</strong>数据观测 —— data 配置之前</p></li><li><p><strong>created：</strong>data 配置完成，可进行 data 修改操作(页面加载就执行)<br>一般在此发送 axios 请求</p></li><li><p><strong>beforeMount：</strong>挂载之前，组件的 render 函数首次执行( render 渲染)</p></li><li><p><strong>mounted：</strong>组件完全渲染到页面中，可以获取真实的 dom 节点了<br>使用 this.$refs 找到 ref 表示的节点</p></li></ul><h2 id="数据更新渲染阶段-data-prop-等发生改变"><a href="#数据更新渲染阶段-data-prop-等发生改变" class="headerlink" title="数据更新渲染阶段(data prop 等发生改变)"></a>数据更新渲染阶段(data prop 等发生改变)</h2><ul><li><p><strong>beforeUpdate：</strong>数据更新时</p></li><li><p><strong>updated：</strong>数据和页面更新完毕，可以获取更新之后的 data 以及真实 dom 节点</p></li></ul><h2 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h2><ul><li><p><strong>beforeDestroy：</strong>实例销毁之前调用，在这一步实例仍然完全可用<br>实例卸载以前调用，可以清理非 vue 资源，防止内存泄露<br>停止计时器等</p></li><li><p><strong>destroyed：</strong>实例销毁后调用，对应 vue 实例的所有指令都被解绑，所有事件监听器被移除，所有子实例也被销毁</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用 VueRouter</title>
    <link href="/2021/07/12/VueRouter/"/>
    <url>/2021/07/12/VueRouter/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><h2 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h2><p>• 安装依赖 router<br>• 新建 router.js 文件，引入依赖和相关组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Home.vue&quot;</span>;<br><span class="hljs-keyword">import</span> Books <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Books.vue&quot;</span>;<br></code></pre></td></tr></table></figure><p>• 将路由功能制作成 vue 中的全局功能，使用 vue 的 use 方法 Vue.use(VueRouter)</p><h2 id="制作路由"><a href="#制作路由" class="headerlink" title="制作路由"></a>制作路由</h2><p>• 创建路由数组 (地址不要写成大写)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/pins/:id&quot;</span>,<br>    <span class="hljs-attr">component</span>: Pins,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pins&quot;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/name&quot;</span>,<br>    <span class="hljs-attr">component</span>: Books,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;name&quot;</span>,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><p>• 根据路由数组创建整体路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes,<br>  <span class="hljs-comment">// 路由模式</span><br>  <span class="hljs-comment">// history 完全仿照浏览器 history 必须给服务器添加配置支持 history</span><br>  <span class="hljs-comment">// hash 锚点模式</span><br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;history&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>• 导出使用 export default router 在 main.js 中添加</p><h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>• 虽然我们使用了 Vue.use 方法 将 VueRouter 制作成了全局功能，但是想要使用创建好的路由还需要将创建好的路由加载到整个 vue 项目中 （在 main.js 中添加）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./router&quot;</span>;<br><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-comment">// router:router,</span><br>  router,<br>  <span class="hljs-comment">// 其实添加 router 属性，主要是跟路由相关组件匹配，还有将 $route 和 $router 挂载到 vue 实例当作公共属性，也就是说所有 vue 组件都会有这两个属性</span><br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> h(App),<br>&#125;).$mount(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>对于两个不同组件，都要使用同一组件来渲染，就要使用动态路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>&#123;<br><span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/pins/:id&quot;</span>,<br><span class="hljs-comment">// 当一个&#x27;路径参数&#x27;使用冒号:标记，匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用</span><br><span class="hljs-attr">component</span>: Pins,<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pins&quot;</span>,<br>&#125;,<br>]<br>&lt;router-link to=<span class="hljs-string">&quot;/books/1&quot;</span>&gt;小册&lt;/router-link&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/books/2&quot;</span>&gt;</span>活动<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是 Books<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>图书：&#123;&#123; $route.params.id &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>• 匹配的优先级：匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-comment">// name:&quot;home&quot;,</span><br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-comment">// 当子路由地址为空，父路由匹配时默认展示</span><br>        <span class="hljs-comment">// 当给父路由设置了 name，如果过有默认子路由，把 name 给默认子路由设置</span><br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">component</span>: List,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-comment">// 嵌套路由的 path 前面不要加 /，或者说前面不要加父路由 path，默认会自动添加</span><br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;:category&quot;</span>,<br>        <span class="hljs-attr">component</span>: List,<br>      &#125;,<br>    ],<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><h3 id="动态路由传参-query-和-params-的区别"><a href="#动态路由传参-query-和-params-的区别" class="headerlink" title="动态路由传参 query 和 params 的区别"></a>动态路由传参 query 和 params 的区别</h3><p>路由跳转的时候传递了一些参数或者查询条件，需要根据这些条件，去展示不同的内容<br>传递方式有两种</p><ol><li><strong>query</strong> 是地址栏的查询部分，也就是 ? 部分</li><li><strong>params</strong> 动态路由参数，只有路由的 path 设置了动态参数的时候才可以传递</li></ol><h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p>• 使用 params 传参，路由配置的时候 path 带上参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"> &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/pins/:type&quot;</span>,<br>    <span class="hljs-attr">component</span>: Pins,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pins&quot;</span>,<br>  &#125;,<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;pins&#x27;, params: &#123; type: &#x27;hot&#x27; &#125; &#125;&quot;</span> &gt;</span>沸点<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/pins/:type&quot;</span>,<br>    <span class="hljs-attr">component</span>: Pins,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pins&quot;</span>,<br>  &#125;,<br><span class="hljs-comment">// 地址：http://localhost:8081/pins/hot</span><br></code></pre></td></tr></table></figure><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>• 使用 query 传参，路由配置的时候 path 不用带参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"> &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/pins&quot;</span>,<br>    <span class="hljs-attr">component</span>: Pins,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pins&quot;</span>,<br>  &#125;,<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;pins&#x27;, query: &#123; type: &#x27;hot&#x27; &#125; &#125;&quot;</span> &gt;</span>沸点<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/pins&quot;</span>,<br>    <span class="hljs-attr">component</span>: Pins,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pins&quot;</span>,<br>  &#125;,<br><span class="hljs-comment">// 地址：http://localhost:8081/pins/hot?type=hot</span><br></code></pre></td></tr></table></figure><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>• router.push()<br>• 想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串</span><br>router.push(<span class="hljs-string">&quot;home&quot;</span>);<br><span class="hljs-comment">// 对象</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;home&quot;</span> &#125;);<br><span class="hljs-comment">// 命名的路由</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-string">&quot;123&quot;</span> &#125; &#125;);<br><span class="hljs-comment">// 带查询参数，变成 /register?plan=private</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&quot;private&quot;</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><p><strong>router.go(n) 和 router.back()</strong></p><p>前进 和 返回 地址</p><p><strong>router.replace()</strong></p><p>跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是替换掉当前的 history 记录。<br>组件</p><p><strong>router-view</strong></p><p>展示页面组件，页面地址和某个路由对象的 path 匹配的话就会展示对应的页面组件<br>匹配的规则是在 routes 中 从上到下 严格完全匹配 (不包含查询部分和锚点部分) 只匹配一个</p><p><strong>router-link</strong></p><p>用来实现路由的跳转，也就是页面跳转</p><ul><li>必须传递 to prop, 值是跳转的地址，当地址和 to 匹配的时候默认就会添加一些激活的类名</li><li>匹配的规则是包含匹配，比如是当地址是 /pins 的时候 匹配 /pins 和 /</li><li>不允许重复导航(从首页跳转首页)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">methods: &#123;<br>  <span class="hljs-function"><span class="hljs-title">goHome</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 不允许重复导航(从首页跳转首页)</span><br>    <span class="hljs-comment">// this.$router.push(&quot;/&quot;); 该方法报错</span><br>    <span class="hljs-built_in">this</span>.$route.name !== <span class="hljs-string">&quot;home&quot;</span> &amp;&amp; <span class="hljs-built_in">this</span>.$router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span> &#125;);<br>    <span class="hljs-built_in">this</span>.$route.path !== <span class="hljs-string">&quot;/&quot;</span> &amp;&amp; <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&quot;/&quot;</span>);<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 组件如何通信</title>
    <link href="/2021/06/12/ComponentCommunication/"/>
    <url>/2021/06/12/ComponentCommunication/</url>
    
    <content type="html"><![CDATA[<h1 id="组件之间的通信方式"><a href="#组件之间的通信方式" class="headerlink" title="组件之间的通信方式"></a>组件之间的通信方式</h1><h2 id="方法一、Props-emit"><a href="#方法一、Props-emit" class="headerlink" title="方法一、Props / $emit"></a>方法一、Props / $emit</h2><p>父组件 A 通过 props 的方式向子组件 B 传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现</p><h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件中如何获取父组件中的数据 users:[“a”,”b”,”c”]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">users</span> <span class="hljs-attr">v-bind:users</span>=<span class="hljs-string">&quot;users&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span></span><br><span class="xml">    //前者自定义名称便于子组件调用，后者要传递数据名</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br>&lt;script&gt;<br><br><span class="hljs-keyword">import</span> Users <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Users&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>      <span class="hljs-attr">users</span>:[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">components</span>:&#123;<br>    <span class="hljs-string">&quot;users&quot;</span>:Users<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//users子组件</span><br>&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;user in users&quot;</span>&gt;</span>&#123;&#123;user&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>//遍历传递过来的值，然后呈现到页面</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;HelloWorld&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">props</span>:&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">users</span>:&#123;           <span class="hljs-comment">//这个就是父组件中子标签自定义名字</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">type</span>:<span class="hljs-built_in">Array</span>,</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span></span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击 h1 后，子组件向父组件传递值，文字由原来的”传递的是一个值”变成”子向父组件传值”，实现子组件向父组件值的传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 子组件</span><br>&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeTitle&quot;</span> &gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">    //绑定一个点击事件</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app-header&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">title</span>:<span class="hljs-string">&quot;我是子组件&quot;</span></span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">methods</span>:&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">changeTitle</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;titleChanged&quot;</span>,<span class="hljs-string">&quot;子向父组件传值&quot;</span>);</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">//自定义事件  传递值&quot;子向父组件传值&quot;</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 传递自定义方法，在子组件使用 this.$emit(&quot;定义名称&quot;,属性值)</span></span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">app-header</span> <span class="hljs-attr">v-on:titleChanged</span>=<span class="hljs-string">&quot;updateTitle&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-header</span>&gt;</span></span><br><span class="xml">    // 与子组件titleChanged自定义事件保持一致</span><br><span class="xml">    // updateTitle($event)接受传递过来的文字</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Header&quot;</span></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">title</span>:<span class="hljs-string">&quot;传递的是一个值&quot;</span></span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">methods</span>:&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">updateTitle</span>(<span class="hljs-params">e</span>)</span>&#123;   <span class="hljs-comment">//声明这个函数</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.title = e;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">components</span>:&#123;</span></span><br><span class="javascript"><span class="xml">   <span class="hljs-string">&quot;app-header&quot;</span>:Header,</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="方法二、-sync-修饰符"><a href="#方法二、-sync-修饰符" class="headerlink" title="方法二、.sync 修饰符"></a>方法二、.sync 修饰符</h2><ul><li><strong>父组件</strong>：:名称.sync =”对象.属性” 相当于将修改 <strong>对象.属性</strong> 的事件传递给子组件</li><li><strong>子组件</strong>：this.$emit(“updata:名称”,属性值)</li></ul><h2 id="方法三、Vuex"><a href="#方法三、Vuex" class="headerlink" title="方法三、Vuex"></a>方法三、Vuex</h2><h3 id="简要介绍-Vuex-原理"><a href="#简要介绍-Vuex-原理" class="headerlink" title="简要介绍 Vuex 原理"></a>简要介绍 Vuex 原理</h3><p>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 进行，Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根据 State 的变化，渲染到视图上</p><h3 id="简要介绍各模块在流程中的功能："><a href="#简要介绍各模块在流程中的功能：" class="headerlink" title="简要介绍各模块在流程中的功能："></a>简要介绍各模块在流程中的功能：</h3><ul><li><p><strong>Vue Components：</strong>Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应</p></li><li><p><strong>state：</strong>页面状态管理容器对象。集中存储 Vue components 中 data 对象的数据，全局唯一，以进行统一的状态管理</p></li><li><p><strong>getters：</strong>state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象</p></li><li><p><strong>mutations：</strong>状态改变操作方法，由 actions 中的 commit(‘mutation 名称’) 来触发。是 Vuex 修改 state 的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一</p></li><li><p><strong>commit：</strong>状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法</p></li><li><p><strong>actions：</strong>操作行为处理模块,由组件中的 $store.dispatch(‘action 名称’, data) 来触发。然后由 commit() 来触发 mutation 的调用 , 间接更新 state。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。</p></li><li><p><strong>dispatch：</strong>操作行为触发方法，是唯一能执行 action 的方法</p></li></ul><h3 id="Vuex-与-localStorage"><a href="#Vuex-与-localStorage" class="headerlink" title="Vuex 与 localStorage"></a>Vuex 与 localStorage</h3><p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在 vuex 里数据改变的时候把数据拷贝一份保存到 localStorage 里面，刷新之后，如果 localStorage 里有保存的数据，取出来再替换 store 里的 state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultCity = <span class="hljs-string">&quot;杭州&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 用户关闭了本地存储功能，此时在外层加个try...catch</span><br>  <span class="hljs-keyword">if</span> (!defaultCity) &#123;<br>    defaultCity = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">window</span>.localStorage.getItem(<span class="hljs-string">&quot;defaultCity&quot;</span>));<br>  &#125;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">city</span>: defaultCity,<br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">changeCity</span>(<span class="hljs-params">state, city</span>)</span> &#123;<br>      state.city = city;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">&quot;defaultCity&quot;</span>, <span class="hljs-built_in">JSON</span>.stringify(state.city));<br>        <span class="hljs-comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面</span><br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>由于 vuex 里，我们保存的状态，都是数组，而 localStorage 只支持字符串，所以需要用 JSON 转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">JSON</span>.stringify(state.subscribeList); <span class="hljs-comment">// array -&gt; string</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">window</span>.localStorage.getItem(<span class="hljs-string">&quot;subscribeList&quot;</span>)); <span class="hljs-comment">// string -&gt; array</span><br></code></pre></td></tr></table></figure><h2 id="方法四、-attrs-listeners"><a href="#方法四、-attrs-listeners" class="headerlink" title="方法四、$attrs / $listeners"></a>方法四、$attrs / $listeners</h2><ul><li><p><strong>$attrs：</strong>包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 interitAttrs 选项一起使用</p></li><li><p><strong>$listeners：</strong>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</p></li></ul><p>简单来说：$attrs 与 $listeners 是两个对象，$attrs 里存放的是<strong>父组件中绑定的非 Props 属性</strong>，$listeners 里存放的是<strong>父组件中绑定的非原生事件</strong></p><h2 id="方法五、provide-inject"><a href="#方法五、provide-inject" class="headerlink" title="方法五、provide / inject"></a>方法五、provide / inject</h2><p>允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//父组件</span><br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;哈哈&quot;</span>,<br>      <span class="hljs-attr">counts</span>: <span class="hljs-string">&quot;咪咪&quot;</span>,<br>    &#125;;<br>  &#125;,<br> <span class="hljs-function"><span class="hljs-title">provide</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">counts</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.counts,<br>      <span class="hljs-attr">changeCount</span>: <span class="hljs-built_in">this</span>.changeCount,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">changeCount</span>(<span class="hljs-params">newCount</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.counts = newCount;<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//子组件</span><br><span class="hljs-attr">inject</span>: [<span class="hljs-string">&quot;counts&quot;</span>],<br>    mounted () &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.counts);<br>    <span class="hljs-comment">// 咪咪</span><br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//子子组件</span><br>  &lt;p&gt;子子组件使用父组件：&#123;&#123; counts() &#125;&#125;&lt;/p&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span> &gt;</span>获取<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  inject: [<span class="hljs-string">&quot;counts&quot;</span>, <span class="hljs-string">&quot;changeCount&quot;</span>],<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.changeCount(<span class="hljs-string">&quot;呱呱&quot;</span>);<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure><h2 id="方法六、-parent-children-与-ref"><a href="#方法六、-parent-children-与-ref" class="headerlink" title="方法六、$parent / $children 与 ref"></a>方法六、$parent / $children 与 ref</h2><ul><li><strong>ref：</strong>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素; -如果用在子组件上，引用就指向组件实例</li><li><strong>$parent / $children：</strong>访问父 / 子实例</li></ul><p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 ref 来访问组件的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// component-a 子组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Vue.js&quot;</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">component-a</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;comA&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">    mounted () &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">const</span> comA = <span class="hljs-built_in">this</span>.$refs.comA;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">console</span>.log(comA.title);  <span class="hljs-comment">// Vue.js</span></span></span><br><span class="javascript"><span class="xml">      comA.sayHello();  <span class="hljs-comment">// 弹窗</span></span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这两种方法<strong>无法在跨级或兄弟间通信</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>常见使用场景可以分为三类：</p><p><strong>父子通信：</strong></p><ul><li>父向子传递数据是通过 props，子向父是通过 $emit;</li><li>通过父链 / 子链也可以通信 ($parent / $children);</li><li>ref 访问组件实例;</li><li>provide / inject;</li><li>$attrs / $listeners</li></ul><p><strong>兄弟通信：</strong></p><ul><li>Bus;</li><li>Vuex</li></ul><p><strong>跨级通信：</strong></p><ul><li>Bus;</li><li>Vuex;</li><li>provide / inject;</li><li>$attrs / $listeners</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 Context</title>
    <link href="/2021/06/10/ReactContext/"/>
    <url>/2021/06/10/ReactContext/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Context"><a href="#什么是-Context" class="headerlink" title="什么是 Context"></a>什么是 Context</h2><p>一个能将 Props 从顶层传递到最底层的方法</p><h2 id="什么时候使用-Context"><a href="#什么时候使用-Context" class="headerlink" title="什么时候使用 Context"></a>什么时候使用 Context</h2><p>有的时候很深层次的后代组件想要使用祖先组件的 state 或者方法，但是中间的组件不需要使用，如果使用 props，中间很多组件需要帮助传递参数，巨麻烦</p><p>使用 Context 不需要中间组件帮忙传递，这种方案要优于 props，且中间组件也可以使用 Context 的 Consumer 接收</p><h2 id="配合小例子搞明白儿的"><a href="#配合小例子搞明白儿的" class="headerlink" title="配合小例子搞明白儿的"></a>配合小例子搞明白儿的</h2><h4 id="实现功能：将-state-和-add-方法传递给子组件及其它的后代组件"><a href="#实现功能：将-state-和-add-方法传递给子组件及其它的后代组件" class="headerlink" title="实现功能：将 state 和 add() 方法传递给子组件及其它的后代组件"></a>实现功能：将 state 和 add() 方法传递给子组件及其它的后代组件</h4><ul><li><p>先创建好 Context.js(祖先)、ContextItem1.js(父级)、ContextItem2.js(子级)三个 js 组件，并引入对应组件内</p></li><li><p>在祖先级组件中创建一个 Context 并导出 Provider(提供) 和 Consumer(消费)</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; Component, createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; Provider, Consumer &#125; = createContext(<span class="hljs-string">&quot;blue&quot;</span>);<br><span class="hljs-comment">// &quot;blue&quot; 是默认值</span><br></code></pre></td></tr></table></figure><ul><li>使用 Provider 组件传递参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 定义的 state</span><br> state = &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">post</span>: <span class="hljs-number">200</span>,<br>  &#125;;<br><span class="hljs-comment">// 传递参数</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.add&#125;</span>&gt;</span>修改count<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">count</span>, <span class="hljs-attr">post</span>, <span class="hljs-attr">add:</span> <span class="hljs-attr">this.add</span> &#125;&#125;&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ContextItem1</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="hljs-comment">// 定义的方法</span><br>  add = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">post</span>: <span class="hljs-number">300</span>,<br>    &#125;);<br>  &#125;;<br></code></pre></td></tr></table></figure><ul><li>接收参数<ul><li>子组件想要使用祖先组件共享的 Context，先导入 Consumer，使用 Consumer 可以获取共享的 Context</li><li>Consumer 的使用方式：给 Consumer 组件传递一个函数，这个函数的参数就是共享 Context 的值，而且这个函数需要返回对应组件的节点内容</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 父级组件内</span><br><span class="hljs-comment">// 导入 Consumer</span><br><span class="hljs-keyword">import</span> &#123; Consumer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Context&quot;</span>;<br><span class="hljs-comment">// 接收参数</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span>&gt;</span></span><br><span class="xml">  &#123;(value) =&gt; (</span><br><span class="xml">    // value 是形参，可以改为其他名字</span><br><span class="xml">    // value 接收的是一个对象，需要使用 value.[属性名]</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;value.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;value.add&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ContextItem2</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  )&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Consumer</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>子级组件接收参数是一样的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; Consumer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Context&quot;</span>;<br><span class="hljs-keyword">const</span> ContextItem2 = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span>&gt;</span></span><br><span class="xml">      &#123;(value) =&gt; (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>&#123;value.post&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      )&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Consumer</span>&gt;</span></span><br>  );<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ContextItem2;<br></code></pre></td></tr></table></figure><h2 id="使用多个-Context"><a href="#使用多个-Context" class="headerlink" title="使用多个 Context"></a>使用多个 Context</h2><ul><li>依然使用刚才创建的组件，创建 Context 导出 Provider、Consume 时起个名字</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">Provider</span>: ThemeProvider, <span class="hljs-attr">Consumer</span>: ThemeConsumer &#125; =<br>  createContext();<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">Provider</span>: DemoProvider, <span class="hljs-attr">Consumer</span>: DemoConsumer &#125; =<br>  createContext();<br></code></pre></td></tr></table></figure><ul><li>使用起好名字的 Provider 组件传递参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-built_in">this</span>.add&#125;&gt;修改count&lt;/button&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeProvider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">count</span>, <span class="hljs-attr">post</span>, <span class="hljs-attr">add:</span> <span class="hljs-attr">this.add</span> &#125;&#125;&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">DemoProvider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ContextItem1</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">DemoProvider</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ThemeProvider</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>使用起好名字的 Consumer 组件接收参数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 子组件内</span><br><span class="hljs-comment">// 导入要使用的 Consumer</span><br><span class="hljs-keyword">import</span> &#123; ThemeConsumer, DemoConsumer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Context&quot;</span>;<br><span class="hljs-comment">// 接收参数</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeConsumer</span>&gt;</span></span><br><span class="xml">  &#123;(themeContext) =&gt; (</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">DemoConsumer</span>&gt;</span></span><br><span class="xml">      &#123;(demoContext) =&gt; (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>&#123;themeContext.post&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>&#123;demoContext&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      )&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">DemoConsumer</span>&gt;</span></span><br><span class="xml">  )&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ThemeConsumer</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>啊，我已经懂了，但是没有完全懂</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零搞清楚什么是构造函数</title>
    <link href="/2021/06/01/Constructor/"/>
    <url>/2021/06/01/Constructor/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是构造函数"><a href="#什么是构造函数" class="headerlink" title="什么是构造函数"></a>什么是构造函数</h1><p>概念：通过 new 关键字来调用的函数，称为构造函数</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>构造函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是防抖节流</title>
    <link href="/2021/05/23/Debounce&amp;Throttle/"/>
    <url>/2021/05/23/Debounce&amp;Throttle/</url>
    
    <content type="html"><![CDATA[<p>什么是快乐星球，什么是防抖节流</p><h2 id="从一个滚动条监听开始说起"><a href="#从一个滚动条监听开始说起" class="headerlink" title="从一个滚动条监听开始说起"></a>从一个滚动条监听开始说起</h2><p>很多网站都有一个 “返回顶部” 按钮，当你向下滚动到一定位置时，这个按钮才会出现。这时候就抽象出这个功能需求——<strong>监听浏览器滚动事件，返回当前滚条与顶部的距离</strong></p><p>这个很简单，直接就是一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showLocation</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;滚动条位置：&quot;</span> + scrollTop);<br>&#125;<br><span class="hljs-built_in">window</span>.onscroll = showLocation;<br></code></pre></td></tr></table></figure><p>这时候你就会发现，好家伙！只需轻轻一滚，就能执行<strong>6-7 次</strong>！</p><!-- <img src="./asd/log.png" width="300" height="300"> --><p><img src="https://raw.githubusercontent.com/happy-mouse/happy-mouse.github.io/master/img/blogShow/log.png"></p><p>然而实际上我们并不需要如此高频的反馈，毕竟浏览器的性能是有限的，不应该浪费在这里，所以接着讨论如何优化这种场景</p><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p><strong>触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</strong></p><p>直接看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 借助闭包</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      <span class="hljs-comment">// 进入该分支语句说明当前正在一个计时过程中，并且又触发了相同事件。</span><br>      <span class="hljs-comment">// 所以要取消当前的计时，重新开始计时</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(fn, delay);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(fn, delay);<br>      <span class="hljs-comment">// 进入该分支说明当前并没有在计时，那么就开始一个计时</span><br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showLocation</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;滚动条位置：&quot;</span> + scrollTop);<br>&#125;<br><span class="hljs-built_in">window</span>.onscroll = debounce(showLocation, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>此时会发现，必须在停止滚动 1 秒以后，才会打印出滚动条位置</p><p>到这里，已经把<strong>防抖</strong>实现了，现在给出定义：</p><ul><li>对于<strong>短时间内连续触发</strong>的事件，防抖就是让<strong>某个时间期限内，事件处理函数只执行一次</strong></li></ul><h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h2><p>对于防抖，如果用户一直拖动进度条，就一直不会触发函数</p><p><strong>如果想让用户在不断拖动滚动条情况下，也能在某个时间间隔之后给出反馈呢？</strong></p><p>那么这是我们就可以设计一个<strong>类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活</strong>（类似于技能冷却时间）</p><p>这里借助 setTimeout 来做一个简单的实现，加上一个状态位 valid 来表示当前函数是否处于工作状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> valid = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!valid) &#123;<br>      <span class="hljs-comment">// 进入该分支跳出函数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 执行函数并且在间隔期内把状态位设为无效</span><br>    valid = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn();<br>      valid = <span class="hljs-literal">true</span>;<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就会发现，如果一直拖着滚动条进行滚动，那么会以 1s 的时间间隔，持续输出当前位置和顶部的距离</p><p>那么同样，<strong>节流</strong>的定义大概为：</p><ul><li><strong>短时间内大量触发</strong>同一事件，那么在函数执行一次之后，<strong>该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈闭包</title>
    <link href="/2021/05/16/Closure/"/>
    <url>/2021/05/16/Closure/</url>
    
    <content type="html"><![CDATA[<p>在搞清楚闭包之前，必须理解 JavaScrip 的变量作用域</p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量的作用域包括两种：<strong>全局变量</strong> 和 <strong>局部变量</strong></p><p>在 JavaScrip 中，函数内部可以直接读取全局变量，而在函数外部无法读取函数内的局部变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 3</span><br>&#125;<br>f1();<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><h2 id="如何从外部读取局部变量"><a href="#如何从外部读取局部变量" class="headerlink" title="如何从外部读取局部变量"></a>如何从外部读取局部变量</h2><p>在函数的内部，再定义一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 3</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，函数 f2 被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。</p><p>这里就提到了 JavaScript 语言特有的 “链式作用域” 结构：子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>这时只要把 f2 作为返回值，就可以在 f1 外部读取它的内部变量了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2;<br>&#125;<br><span class="hljs-keyword">var</span> post = f1();<br><br>post(); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>上述的 f2 函数就是闭包，<strong>闭包就是能够读取其他函数内部变量的函数</strong></p><h2 id="闭包有什么用"><a href="#闭包有什么用" class="headerlink" title="闭包有什么用"></a>闭包有什么用</h2><p>闭包最大的用处有两个：</p><ul><li><p>可以读取函数内部的变量</p></li><li><p>让这些变量的值始终保持在内存中</p></li></ul><p>那是什么意思呢，我们看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br>  add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    n += <span class="hljs-number">1</span>;<br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2;<br>&#125;<br><span class="hljs-keyword">var</span> result = f1();<br>result(); <span class="hljs-comment">// 1</span><br>add();<br>result(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在这段代码中，result 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 1，第二次的值是 2。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。</p><p>为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个<strong>全局变量</strong>，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p><h2 id="使用闭包要注意"><a href="#使用闭包要注意" class="headerlink" title="使用闭包要注意"></a>使用闭包要注意</h2><ul><li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除</p></li><li><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值</p></li></ul><h2 id="闭包经典易错题"><a href="#闭包经典易错题" class="headerlink" title="闭包经典易错题"></a>闭包经典易错题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">n, o</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(o);<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">fun</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> fun(m, n);<br>    &#125;,<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = fun(<span class="hljs-number">0</span>);<br>a.fun(<span class="hljs-number">1</span>);<br>a.fun(<span class="hljs-number">2</span>);<br>a.fun(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">var</span> b = fun(<span class="hljs-number">0</span>).fun(<span class="hljs-number">1</span>).fun(<span class="hljs-number">2</span>).fun(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">var</span> c = fun(<span class="hljs-number">0</span>).fun(<span class="hljs-number">1</span>);<br>c.fun(<span class="hljs-number">2</span>);<br>c.fun(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>在这里就要搞清楚 <strong>var a = fun(0)</strong> 和 <strong>a.fun(0)</strong> 分别执行的是什么</p><ul><li><p>var a = fun(0) 就是在执行第一层的具名函数 fun()</p></li><li><p>a.fun(0) 调用 fun() 的对象属性 fun:function(){}</p></li></ul><p>然后我们回过头来看第一个变量 a</p><ul><li>第一次执行，带入 0 ，此时 n = 0，o 未定义，所以会输出 undefined</li><li>第二次执行，调用 fun(1) 时 m 为 1，此时 fun 闭包了外层函数的 n，也就是第一次调用的 n = 0，即 m = 1，n = 0，并在内部调用第一层 fun 函数 fun(1,0)，所以 o 为 0；</li><li>第三次执行，调用 fun(2) 时 m 为 2，但依然是调用 a.fun，所以还是闭包了第一次调用时的 n，所以内部调用第一层的 fun(2,0)，所以 o 为 0</li><li>第四次同理</li></ul><p>所以最后的结果为：undefined 0 0 0</p><p>然后我们看第二个变量 b</p><ul><li>第一次执行，同上一个 a 的相同，输出 undefined</li><li>第二次执行，是在第一次执行的基础上执行，带入 1 到第二层 fun 函数中，m = 1，由于闭包的作用，此时的 n = 0（第一次执行的时候存储的）。return 出去，m 是第一个参数，n 是第二个参数（会拿到存储的 0），所以会输出 0</li><li>第三次执行，是在第二次执行的基础上执行，带入 2 到第二层 fun 函数中，m = 2，n 由于上次的 m 已经将 n 赋值为 1。return 出去，m 是第一个参数，n 是第二个参数，所以会输出 1</li><li>第四次执行，是在第三次执行的基础上执行，带入 3 到第二层 fun 函数中，m = 3，n 由于上次的 m 已经将 n 赋值为 2。return 出去，m 是第一个参数，n 是第二个参数，所以会输出 2</li></ul><p>所以最后的结果为：undefined 0 1 2</p><p>最后来看第三个变量 c</p><ul><li>第一次执行，同上，输出 undefined</li><li>第二次执行，调用 fun(1) 时 m 为 1，此时 fun 闭包了外层函数的 n，也就是第一次调用的 n = 0，即 m = 1，n = 0，并在内部调用第一层 fun 函数 fun(1,0)，所以 o 为 0</li><li>第三次执行，调用 .fun(2)时 m 为 2，此时 fun 闭包的是第二次调用的 n = 1，即 m = 2，n = 1，并在内部调用第一层 fun 函数 fun(2,1)，所以 o 为 1</li><li>第四次执行，fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层 fun 函数 fun(3,1)，所以 o 还为 1</li></ul><p>所以最后的结果为：undefined 0 1 1</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios 请求拦截器和响应拦截器</title>
    <link href="/2021/05/12/Axios/"/>
    <url>/2021/05/12/Axios/</url>
    
    <content type="html"><![CDATA[<h3 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h3><p>作用：在请求发送前进行一些操作，例如加请求头、token 等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置请求基地址</span><br>axios.defaults.baseURL = <span class="hljs-string">&#x27;http://127.0.0.1:8888/ api/private/v1/&#x27;</span><br><span class="hljs-comment">// axios请求拦截器</span><br><span class="hljs-keyword">let</span> token = <span class="hljs-string">&quot;&quot;</span><br>axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span>&#123;<br>  <span class="hljs-comment">//在发送请求之前做些什么</span><br>  <span class="hljs-keyword">if</span> (!token)&#123;<br>    token = <span class="hljs-built_in">window</span>.sessionstorage.getItem( <span class="hljs-string">&#x27;token &quot;)</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  else &#123;</span><br><span class="hljs-string">    config.headers.Authorization = token</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  return config</span><br><span class="hljs-string">&#125;)</span><br><span class="hljs-string">axios.interceptors.response.use(res =&gt; res.data)</span><br><span class="hljs-string">Vue.prototype.$axios = axios</span><br></code></pre></td></tr></table></figure><h3 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h3><p>作用：在接收到响应后进行一些操作，例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-comment">// 在接收响应做些什么，例如跳转到登录页</span><br>    ......<br>    <span class="hljs-keyword">return</span> response;<br>  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-comment">// 对响应错误做点什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="移除拦截器"><a href="#移除拦截器" class="headerlink" title="移除拦截器"></a>移除拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">/*...*/</span><br>&#125;);<br>axios.interceptors.request.eject(myInterceptor);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC 和 MVVM 是个啥</title>
    <link href="/2021/03/22/MVCandMVVM/"/>
    <url>/2021/03/22/MVCandMVVM/</url>
    
    <content type="html"><![CDATA[<p>MVC 和 MVVM 是一种程序开发设计模式</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="什么是-MVC"><a href="#什么是-MVC" class="headerlink" title="什么是 MVC"></a>什么是 MVC</h2><p>MVC 是 Model View Controller 的缩写</p><ul><li><p>Model：模型层，可以在数据库中存取数据，用于处理数据逻辑</p></li><li><p>View：视图层，渲染用户界面逻辑</p></li><li><p>Controller：控制器，接收来自视图界面的请求，并交给模型进行处理，起到了一个连接的作用</p></li></ul><h2 id="它们仨什么关系"><a href="#它们仨什么关系" class="headerlink" title="它们仨什么关系"></a>它们仨什么关系</h2><p>看图说话</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90dFZXdXJMb0dWaWFkeUV6WllDRWlhbXIxSWhKaWNlMUpGUXlCaEQ1Q2RQSHA0RllnRXVVVGVaRDk0RzdKYUNHS3BYNGhpYTdibm1rcU9Fbk5FcEppYUhCaWJSUS82NDA?x-oss-process=image/format,png#pic_center" alt="三者关系图"></p><p>大致过程：</p><p>用户在视图交互，然后请求发送到控制器，控制器根据请求类型和请求的指令发送到相应的模型，模型可以与数据库进行交互，一通操作之后（指增删改查），根据业务的逻辑选择相应的视图进行显示，用户获得此次交互的反馈信息</p><h2 id="MVC-的特点"><a href="#MVC-的特点" class="headerlink" title="MVC 的特点"></a>MVC 的特点</h2><p>模型和视图之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。</p><h2 id="MVC-的优点"><a href="#MVC-的优点" class="headerlink" title="MVC 的优点"></a>MVC 的优点</h2><ul><li>耦合性低</li></ul><p>视图层和业务层分离，允许更改视图层代码而不用重新编译模型和控制器代码（改写html, css, javascirpt 的代码，并不需要重启服务器）</p><ul><li>重用性高</li></ul><p>分层后更有利于组件的重用：控制层可独立成一个能用的组件，视图层也可做成通用的操作界面</p><ul><li>可维护性高</li></ul><p>分离视图层和业务逻辑层使得 Web 应用更易于维护和修改</p><h2 id="MVC-的缺点"><a href="#MVC-的缺点" class="headerlink" title="MVC 的缺点"></a>MVC 的缺点</h2><ul><li>视图与控制器连接过于紧密</li></ul><p>虽然视图与控制器是相互分离，但是它们又联系紧密，视图没有控制器的存在，其应用是很有限的，反之亦然，所以会影响它们的独立重用</p><ul><li>不适合小型，中等规模的应用程序</li></ul><p>花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失（例如仅仅需要到数据库查信息，如果不分层设计我们可以直接从视图型层到模型去访问，效率上会有所提高，如果以代码的复杂性为代价，多了一层，代码量大大增加，在这个时候就降低了开发效率）</p><ul><li>视图对模型数据的低效率访问</li></ul><p>依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p><ul><li>一般高级的界面工具或构造器不支持模式</li></ul><p>改造这些工具以适应MVC需要和建立分离的部件的代价很高，造成 MVC 使用的困难。</p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><p>MVVM 是 Model View ViewModel 的缩写</p><ul><li><p>Modal：模型层，指的是后端传递的数据</p></li><li><p>View：视图层，指的是所看到的页面</p></li><li><p>ViewModal：视图模型层，MVVM 模式的核心，它是连接view和model的桥梁，主要用来处理业务逻辑</p></li></ul><h2 id="它们三个有什么关系"><a href="#它们三个有什么关系" class="headerlink" title="它们三个有什么关系"></a>它们三个有什么关系</h2><p>直接看图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90dFZXdXJMb0dWaWFkeUV6WllDRWlhbXIxSWhKaWNlMUpGUW9CN2M3QjlDZ0NQSDIzYVV4QjBnNzI5WkNVMERWbnBJZEh3Mzl0aWJWNlJJdWpwdEFET1VIaWJnLzY0MA?x-oss-process=image/format,png#pic_center" alt="三者关系图"></p><p>大致过程：</p><ul><li><p>将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。</p></li><li><p>将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</p></li><li><p>两个方向都实现的，就是数据的双向绑定。</p></li></ul><h2 id="MVVM-的特点"><a href="#MVVM-的特点" class="headerlink" title="MVVM 的特点"></a>MVVM 的特点</h2><p>在MVVM的框架下，视图和模型是不能直接通信的，它们通过 ViewModal 来通信，ViewModel 通常要实现一个observer 观察者。当数据发生变化，ViewModel 能够监听到数据的这种变化，然后通知到对应的视图做自动更新；而当用户操作视图，ViewModel 也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。</p><h2 id="MVVM-的优点"><a href="#MVVM-的优点" class="headerlink" title="MVVM 的优点"></a>MVVM 的优点</h2><ul><li>低耦合</li></ul><p>视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</p><ul><li>可重用性</li></ul><p>可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</p><ul><li>可测试性</li></ul><p>界面向来是比较难于测试的，而现在测试可以针对 ViewModel 来写</p><ul><li>双向数据绑定</li></ul><p>它实现了 View 和 Model 的自动同步，当 Model 的属性改变时，不需要手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变</p><h2 id="MVVM-的缺点"><a href="#MVVM-的缺点" class="headerlink" title="MVVM 的缺点"></a>MVVM 的缺点</h2><ul><li>数据绑定难以调试</li></ul><p>你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易</p><ul><li>占用内存</li></ul><p>一个大的模块中 model 也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存 </p><ul><li>数据双向绑定不利于代码重用</li></ul><p>客户端开发最常用的重用是 View，但是数据双向绑定技术，让你在一个 View 都绑定了一个 model，不同模块的 model 都不同。那就不能简单重用 View 了</p><h1 id="MVC-和-MVVM-的区别"><a href="#MVC-和-MVVM-的区别" class="headerlink" title="MVC 和 MVVM 的区别"></a>MVC 和 MVVM 的区别</h1><ul><li><p>MVVM 实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变。</p></li><li><p>MVC 是系统架构级别的（描述了构成系统的抽象组件，以及各个组件之间的是如何进行通讯），而 MVVM 只用于单页面上的。因此 MVVM 的灵活性要远大于 MVC</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
